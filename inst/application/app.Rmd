---
title: "CCISS BEC"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    logo: www/logo.svg
    favicon: www/favicon.ico
    theme: flatly
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(bccciss)
  library(shiny)
  library(leaflet)
  library(DT)
  library(bcmaps)
})
## BEC Map data, bit transformed for faster processing
# Again this could be done with postgis instead
# This particular sf has zones over water bodies
bec <- bcmaps::bec(ask = FALSE)
# reclass as data.table to allow data.table operation
data.table::setDT(bec)
data.table::set(
  bec,
  j = c("xmin", "ymin", "xmax", "ymax"),
  value = data.table::rbindlist(lapply(bec$geometry, function(x) as.list(sf::st_bbox(x))))
)

```


BEC MAP
=====================================  

Inputs {.sidebar data-width=500}
-------------------------------------

#### Points
<hr>  
Click on the map to add points or enter data below. Double click row to edit. Ctrl+Enter to confim,

```{r}
actionButton("add_button", "Add", icon("plus"))
actionButton("delete_button", "Delete", icon("trash-alt"))
actionButton("upload_button", "Upload", icon("upload"))
actionButton("clear_button", "Clear", icon("broom"))
DT::DTOutput("points_table", width="100%")
selectInput("rcp_scenario", "RCP Scenario:", selected = "4.5", c("4.5", "8.5"), multiple = TRUE, width = 150)
radioButtons("aggregation", "Multiple Point Aggregation:", c("Individual" = FALSE, "Averaged by BGC Zone" = TRUE), inline = TRUE)
```

[How the CCISS tool works](./#section-how-the-cciss-tool-works)

Biogeoclimatic Zones + Subzones Variants Map
-------------------------------------
```{r}
leafletOutput("bec_map", width = "100%", height = "100%")

```

SPECIES SUITABILITY
=====================================     

### Species Suitability

Site Series
{insert name of site series}

Predicted Suitability

```{r}
```
   
SILVICULTURE
=====================================     

### Silviculture

Site Series
{insert name of site series}

Forest Region:
    
```{r}
```


BGC FUTURES
=====================================     

### BGC Futures: ratio of models predicting BGC

Current BGC : {insert current}
 
```{r}
```

... to PDF {data-navmenu="EXPORT" .navbar-right}
=====================================

... to HTML {data-navmenu="EXPORT" .navbar-right}
=====================================

How the CCISS tool works {data-navmenu="ABOUT"} 
=====================================

The Climate Change Informed Species Selection Decision Aid provides information on future tree species suitability in British Columbia. It combines future climate information with species viability models to illustrate how likely each species is to thrive in the range of potential futures.  

The CCISS tool reassesses the suitability ranks of species at a site series level under multiple plausible modelled future climates. Understanding climate- and site-level species suitability is one of the foundational pieces of information that a forester requires for the creation of successful silvicultural prescriptions over a rotation. The CCISS tool looks at near- and mid-term projected changes to BGC climates and the implications to species suitability. The tool then aligns the projected future suitability rank of species at a POI with the suitability in the default stocking standards outlined in the Chief Foresterâ€™s Reference Guide to highlight where there are predicted climate change induced shifts in species suitability. This information can be used to inform planting/ silvicultural prescription outlined in climate change informed stocking standard. The CCISS tool is spatial explicit to account for the gradient of climate change that will different regions and elevations of a BGC.  
  
[Would you like to know more?](https://www.for.gov.bc.ca/ftp/HRE/external/!publish/CCISS/CCISS_in_Stocking%20Standards.pdf)


```{r server_elements, context="server"}

# Proxy objects
DT_proxy <- DT::dataTableProxy("points_table")
map_proxy <- leaflet::leafletProxy('bec_map')

# Input management ----

## Points dataframe
uData <- session$userData

uData$points <- uData$basepoints <- data.table(
  ID = integer(),
  Latitude = numeric(),
  Longitude = numeric(),
  Elevation = numeric(),
  BGC = character(),
  popups = character()
)

## Exclude popups column
output$points_table <- DT::renderDataTable({
  DT::datatable(
    uData$points[j = 1L:5L], rownames = FALSE,
    options = list(searching = FALSE, lengthChange = TRUE, pageLength = 5),
    editable = list(target = "row", disable = list(columns = c(0,4)))
  )
})


## Interface redraw methods
update_DT <- function() {
  DT::replaceData(DT_proxy, uData$points[j = 1L:5L], clearSelection = "all", rownames = FALSE)
}

clear_mk <- function() {
  leaflet::clearMarkers(map_proxy)
}

draw_mk <- function(data = uData$points) {
  non_na_idx <- which(!is.na(data$Longitude) & !is.na(data$Latitude))
  leaflet::addCircleMarkers(map_proxy, lng = ~Longitude, lat = ~Latitude,
                            data = data[i = non_na_idx],
                            radius = 6, color = "#444", fillColor = "orangered", stroke = TRUE,
                            fillOpacity = 0.6, opacity = 0.8, weight = 2,
                            popup = ~popups) 
}

## Points update logic
update_ID <- function() {
  uData$points[, ID := seq_len(nrow(uData$points))]
}

new_points <- function(points) {
  beg <- nrow(points)
  withProgress(min = 0, max = 3, detail = "Adding points ...", {
    setProgress(1, message = "Fetch points details")
    points <- points[!is.na(Longitude) & !is.na(Latitude)]
    points[,`:=`(Longitude = round(Longitude, 5), Latitude = round(Latitude, 5))]
    res <- localGetBecInfo(points, "Longitude", "Latitude", bec)
    points <- res$points
    if (nrow(points) > 0) {
      points[, BGC := res$info$BGC_LABEL]
      # TODO
      # Fetch elevation from where?
      # points[is.na(Elevevation), Elevation := bcmaps::cded(...)]
      setProgress(2, message = "Create popup info")
      popups <- res$info[, paste("<b>", names(.SD), ":</b>", .SD, collapse = "<br />"), by=1:NROW(res$info)]$V1
      points[, popups := sapply(popups, htmltools::HTML)]
    }
    points <- rbindlist(list(uData$basepoints, points), fill = TRUE)
    setProgress(3, message = "Done")
  })
  end <- nrow(points)
  if (beg != end) {
    showModal(
      modalDialog(
        title = "Warning",
        paste("Points outside of coverage zones were dropped or not updated." ),
        easyClose = TRUE
      )
    )
  }
  return(points)
}

insert_points <- function(points) {
  if (nrow(points)) {
    uData$points <- rbindlist(list(uData$points, points), fill = TRUE)
    update_ID()
    update_DT()
    draw_mk(points)
  }
}

## Upload points logic
observeEvent(input$upload_button,{
  showModal(
    modalDialog(
      fileInput(inputId = "points_upload", label =  "Upload points in a delimited files",
                accept = c(".csv", ".txt"), buttonLabel = "Browse...", placeholder = "My points")
    )
  )
})

observeEvent(input$points_upload,{
  insert_points_file(input$points_upload$datapath)
})

insert_points_file <- function(datapath){
  # Columns detection using regular expression, hopefully column names have a match
  points <- fread(datapath)
  lat_j <- head(grep("^lat|latitude", names(points), ignore.case = TRUE), 1)
  lng_j <- head(grep("^lng|^long|longitude", names(points), ignore.case = TRUE), 1)
  ele_j <- head(grep("^elev|elevation", names(points), ignore.case = TRUE), 1)
  cln_j <- function(j) {
    if (length(j) > 0) {
      as.numeric(points[[j]])
    } else {
      NA_real_
    }
  }
  points <- data.table(Latitude = cln_j(lat_j), Longitude = cln_j(lng_j),
                       Elevation = cln_j(ele_j))
  points <- new_points(points)
  insert_points(points)
}

## Add a point logic
observeEvent(input$add_button,{
  uData$points <- rbindlist(list(uData$points, data.table(ID=NA_integer_)), fill = TRUE)
  update_ID()
  update_DT()
})

## Delete selected points logic
observeEvent(input$delete_button,{
  if(length(input$points_table_rows_selected)>=1) {
    uData$points <- uData$points[-input$points_table_rows_selected]
    update_DT()
    clear_mk()
    draw_mk()
  } else {
    showModal(
      modalDialog(
        title = "Warning",
        paste("Please select row(s)." ),
        easyClose = TRUE
      )
    )
  }
})

## Clear all points logic
observeEvent(input$clear_button,{
  uData$points <- uData$basepoints
  update_DT()
  clear_mk()
})

## Edit points logic
observeEvent(input$points_table_cell_edit, {
  info = input$points_table_cell_edit
  points <- data.table(
    ID = as.numeric(info$value[1]),
    Longitude = as.numeric(info$value[2]),
    Latitude = as.numeric(info$value[3]),
    Elevation = as.numeric(info$value[4])
  )
  points <- new_points(points)
  if (nrow(points)) {
    set(uData$points, info$row[1], points)
    clear_mk()
    draw_mk()
  }
  update_DT()
})

# Map ----

output$bec_map <- renderLeaflet({
  bccciss_map()
})

## Map click logic
observeEvent(input$bec_map_click, {
  pos <- input$bec_map_click
  points <- new_points(data.table(Latitude = pos$lat, Longitude = pos$lng))
  insert_points(points)
})


```
