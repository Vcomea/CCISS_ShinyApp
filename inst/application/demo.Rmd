---
title: "Demo"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    logo: www/logo.svg
runtime: shiny_prerendered
---

```{r setup, include=FALSE}

# Document dependencies
# library(sf)
# library(geojsonsf)
library(CCISS)
# library(units)
library(leaflet)
library(leaflet.extras)
library(leafpop)
library(htmltools)
library(htmlwidgets)

# This function reads in reference data table and assign
# `fillColorZone` and `fillColorSubzone` to x matching the
# concatenation of `keys` with the `classification` column.
fill_colorways <- function(x, keys, colours) {
  
  # Remove NAs and paste
  clean_key <- function(keys) {
    keys <- lapply(keys, function(k) {
      k <- x[[k]]
      k[is.na(k)] <- ""
      k
    })
    return(do.call(paste0, keys))
  }
  
  # Zones
  zones_keys <- "ZONE"
  x[["fillColorZone"]] <- zones_colours_ref[clean_key(zones_keys)]$colour
  
  # Subzones
  subzones_keys <- c("ZONE", "SUBZONE", "VARIANT")
  x[["fillColorSubzone"]] <- subzones_colours_ref[clean_key(subzones_keys)]$colour
  
  return(x)
}

# Main data geo data source. Simplified to be somewhat usable
# in the browser. geojson file size should not be more than
# 5-10 Mb. Otherwise a vector tiles server should be used.
# bec <- sf::st_read("./data_map/BEC_BIOGEOCLIMATIC_POLY/") %>%
#   sf::st_set_precision(units::as_units(300, "m")) %>%
#   sf::st_simplify(dTolerance = 300) %>%
#   sf::st_transform(4326) %>%
#   fill_colorways() %>%
#   geojsonsf::sf_geojson() %>%
#   saveRDS("bec.RDS")
bec <- readRDS(system.file("application/demo/bec.RDS", package = "CCISS"))

# Additional leaflet plugins registration
registerPlugin <- function(map, plugin) {
  map$dependencies <- c(map$dependencies, list(plugin))
  map
}

# VectorGrid is a leaflet extension to display gridded vector data (sliced GeoJSON, TopoJSON or protobuf vector tiles) in Leaflet 1.0.0
# https://github.com/Leaflet/Leaflet.VectorGrid
vgplugin <- htmltools::htmlDependency(
  name = "leaflet.vectorgrid",
  version = "1.3.0",
  src = c(file="./js/"),
  script = "Leaflet.VectorGrid.bundled.min.js"
)

#WMS config for USGS Hill Shade layer
usgs_url <- "https://basemap.nationalmap.gov:443/arcgis/services/USGSShadedReliefOnly/MapServer/WmsServer?"
usgs_layers <- "0"
usgs_options <- WMSTileOptions(format = "image/png",
                               crs = leafletCRS(crsClass = "L.CRS.EPSG4326"),
                               transparent = FALSE)
usgs_attribution <- '<a href="https://catalog.data.gov/dataset/usgs-hill-shade-base-map-service-from-the-national-map">USGS</a>'

#WMS config for BEC layer (for greater visual precision at higher zoom level)
bec_url <- "https://openmaps.gov.bc.ca/geo/pub/WHSE_FOREST_VEGETATION.BEC_BIOGEOCLIMATIC_POLY/ows?"
bec_layers <- "pub:WHSE_FOREST_VEGETATION.BEC_BIOGEOCLIMATIC_POLY"
bec_options <- WMSTileOptions(format = "image/png",
                              crs = leafletCRS(crsClass = "L.CRS.EPSG4326"),
                              transparent = TRUE,
                              style = "1409_1410")
bec_attribution <- '<a href="https://catalogue.data.gov.bc.ca/dataset/bec-map">BEC Map</a>'

# Popup table creator
pop_info <- function(properties) {
  properties <- lapply(
    properties, function(p) {if (is.null(p)) "null" else p}
  )
  data.table::setDT(properties)
  leafpop::popupTable(
    properties,
    row.numbers = FALSE,
    feature.id = FALSE,
    zcol = head(names(properties), -2)
  )
}

```

Inputs {data-width=250 .sidebar}
=====================================

### Climate Change Informed Species Selection Decision Aid

The Climate Change Informed Species Selection Decision Aid provides information on future tree species suitability in British Columbia. It combines future climate information with species viability models to illustrate how likely each species is to thrive in the range of potential futures.

[How the CCISS tool works](./#section-how-the-cciss-tool-works)

For this Demo, I'm using a simplified geojson with a size of ~50MB.
The map will appear when the data finish loading. I've only
implemented map pop up information.

```{r}
textInput("reportName", "Report Name", placeholder = "My Custom Report")

```

#### Points
<hr>  
Click on the map to add points or enter data below.

```{r}
numericInput("lat", "Latitude", min = 48.22484, max = 60.00193, step = 0.00001, width = "160px", value = 56.789)
numericInput("lng", "Longitude", min = -139.0613, max = -114.0541, step = 0.00001, width = "160px", value = -123.4)
actionButton("add_pts", "ADD POINT", width = "120px")

```



BEC MAP
=====================================  

### Biogeoclimatic Zones + Subzones Variants Map 
    

```{r}
leafletOutput("bec_map", width = "100%", height = "100%")

```

SPECIES SUITABILITY
=====================================     

### Species Suitability

Site Series
{insert name of site series}

Predicted Suitability

```{r}
```
   
SILVICULTURE
=====================================     

### Silviculture

Site Series
{insert name of site series}

Forest Region:
    
```{r}
```


BGC FUTURES
=====================================     

### BGC Futures: ratio of models predicting BGC

Current BGC : {insert current}
 
```{r}
```

How the CCISS tool works {data-navmenu="ABOUT"} 
=====================================

The CCISS tool reassesses the suitability ranks of species at a site series level under multiple plausible modelled future climates. Understanding climate- and site-level species suitability is one of the foundational pieces of information that a forester requires for the creation of successful silvicultural prescriptions over a rotation. The CCISS tool looks at near- and mid-term projected changes to BGC climates and the implications to species suitability. The tool then aligns the projected future suitability rank of species at a POI with the suitability in the default stocking standards outlined in the Chief Foresterâ€™s Reference Guide to highlight where there are predicted climate change induced shifts in species suitability. This information can be used to inform planting/ silvicultural prescription outlined in climate change informed stocking standard. The CCISS tool is spatial explicit to account for the gradient of climate change that will different regions and elevations of a BGC.  
  
[Would you like to know more?](https://www.for.gov.bc.ca/ftp/HRE/external/!publish/CCISS/CCISS_in_Stocking%20Standards.pdf)

Hire the guy who did this {data-navmenu="ABOUT"}
=====================================
Bruno Tremblay  
Github: [\@meztez](https://github.com/meztez)  
Twitter: [\@meztez2](https://twitter.com/meztez2)  
Contact: [treeforce@neoxone.com](mailto:treeforce@neoxone.com)  


```{r server_elements, context="server"}

output$bec_map <- renderLeaflet({
    
  leaflet() %>%
    setView(lng = -120.5687032, lat = 54.1414255, zoom = 7) %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "Satellite")  %>%
    addWMSTiles(baseUrl = usgs_url,
                layers = usgs_layers,
                options = usgs_options, group = "Hillshade",
                attribution = usgs_attribution) %>%
    addProviderTiles(providers$OpenStreetMap, group = "OpenStreetMap") %>%
    addWMSTiles(baseUrl = bec_url,
                layers = bec_layers,
                options = bec_options,
                group = "BEC WMS",
                attribution = bec_attribution) %>%
    hideGroup("BEC WMS") %>%
    addMeasure(
      position = "bottomleft",
      primaryLengthUnit = "meters",
      secondaryLengthUnit = "kilometers",
      primaryAreaUnit = "sqmeters") %>%
    addSearchOSM(options = searchOptions(collapsed = FALSE)) %>%
    registerPlugin(vgplugin) %>%
    # This is a custom javascript to enable VectorGrid with Shiny
    # using BEC geojson data
    # https://leaflet.github.io/Leaflet.VectorGrid/vectorgrid-api-docs.html
    htmlwidgets::onRender('
      function(el, x, data) {
        
        var vectorTileOptions = {
          rendererFactory: L.canvas.tile,
          vectorTileLayerName : "bec_vgrid",
          interactive: true, // makes it able to trigger js events like click
          vectorTileLayerStyles: {
            bec_vgrid: function(properties, zoom) {
              // This the where we use the fillColorZone/Subzone
              // properties to style each feature. Switch
              // colors between Zone and Subzone depending
              // on zoom level.
              var color = properties.fillColorSubzone;
              if (zoom < 5) {
                color = properties.fillColorZone;
              }
              return {
                weight: 0,
                fillColor: color,
                fillOpacity: 0.75,
                fill: true
              }
            }
          },
          // This allow each feature to have an identifier
          // equal to OBJECTID property
          getFeatureId: function(f) {
            return f.properties["OBJECTID"];
          },
          // This assign the grid to the overlay layer
          // so it will drawn above the base map layer 
          pane : "overlayPane"
        };
        
        // Create the vector grid layer and add to the widget
        // using the same methods as would R leaflet package.
        var vectorLayer = L.vectorGrid.slicer(data, vectorTileOptions);
        this.layerManager.addLayer(
          vectorLayer, // layer
          "tile", // category
          "bec_vgrid", // layerId
          "Zones + Subzones Variants" // group
        );
        // Define a js onClick event to trigger a Shiny event with bec_cur
        vectorLayer.on("click",
          function(e) {
            if (e.layer.properties) {
              Shiny.setInputValue("bec_cur", {
                latlng: e.latlng,
                properties: e.layer.properties
              });
            }
          }
        );
        
      }', data = bec) %>%
    addLayersControl(
      baseGroups = c("Satellite", "Hillshade", "OpenStreetMap"),
      overlayGroups = c("Zones + Subzones Variants", "BEC WMS"),
      position = "topright"
    )
  
})

# Monitor `bec_cur` to show feature information
observeEvent(input$bec_cur, {
  cur <- input$bec_cur
  if (is.null(cur$latlng) || is.null(cur$properties)) {
    return(NULL)
  }
  leafletProxy('bec_map') %>%
    clearPopups() %>%
    addPopups(lng = cur$latlng$lng, lat = cur$latlng$lat,
              popup = pop_info(cur$properties),
              group = "popups")
  
})


```
